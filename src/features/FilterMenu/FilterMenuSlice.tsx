import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';

import { Patient } from '../../interface/Patient';

import dataGenerated from '../../../data/generated.json'

const patients = dataGenerated as Patient[];

let maxEdge_voluptate = 0, maxEdge_aliquip = 0, maxEdge_consectetur = 0, maxEdge_laboris = 0;
let arrconcat_voluptate: number [] = [], arrconcat_aliquip: number[] = [], arrconcat_consectetur:number[] = [], arrconcat_laboris:number[] = [];
patients.map(p => p.medTests.map( m=> (m.testName==='voluptate')? arrconcat_voluptate = arrconcat_voluptate.concat( [... m.listRecords.map(r => r.score)] )
    : (m.testName==='aliquip')? arrconcat_aliquip = arrconcat_aliquip.concat( [... m.listRecords.map(r => r.score)]) 
    : (m.testName==='consectetur')? arrconcat_consectetur = arrconcat_consectetur.concat( [... m.listRecords.map(r => r.score)]) 
    :  arrconcat_laboris = arrconcat_laboris.concat( [... m.listRecords.map(r => r.score)]) 
    ) )
maxEdge_voluptate=Math.max(...arrconcat_voluptate), maxEdge_aliquip=Math.max(...arrconcat_aliquip), maxEdge_consectetur=Math.max(...arrconcat_consectetur), maxEdge_laboris=Math.max(...arrconcat_laboris);


export interface FilterMenuState {
    minEdge: Array<number>;
    maxEdge: Array<number>;
    minThreshold: Array<number>;
    maxThreshold: Array<number>;
    // status: 'idle' | 'loading' | 'failed';
    valueName: Array<'voluptate' | 'aliquip' | 'consectetur' | 'laboris'>; // doubt whether we want this...
    patients:Array<Patient>,
  }

  const initialState: FilterMenuState = {
    minEdge: [0,0,0,0],
    maxEdge: [maxEdge_voluptate,maxEdge_aliquip,maxEdge_consectetur,maxEdge_laboris],
    minThreshold: [0,0,0,0],
    maxThreshold: [maxEdge_voluptate,maxEdge_aliquip,maxEdge_consectetur,maxEdge_laboris],
    // status: 'idle',
    valueName: ['voluptate','aliquip','consectetur','laboris'],
    patients : patients,
  };

  // verify according to stringVer what is the valueName of medical test and identify index in arrays of values
  const returnIndexValName = (stringVer:string, arrVer:Array<string>) => {
    let indexThresh = -1;
    switch (stringVer){
      case 'voluptate':
        indexThresh = arrVer.indexOf('voluptate');
        break;
      case 'aliquip':
        indexThresh = arrVer.indexOf('aliquip');
        break;
      case 'consectetur':
        indexThresh = arrVer.indexOf('consectetur');
        break;
      case 'laboris':
        indexThresh = arrVer.indexOf('laboris');
        break;
    }
    return indexThresh;
  }

  export interface MenuSlice {
    valueName:string,
    value:number
  }  

  export const filterMenuSlice = createSlice({
    name: 'filterMenu',
    initialState,
    reducers: {
      // Use the PayloadAction type to declare the contents of `action.payload`
      incrementByAmountMenu: (state, action: PayloadAction<MenuSlice>) => {
        // state.attrName = state.attrName.substr(0, state.attrName.indexOf('-') + 1) + (parseInt(state.attrName.substr(state.attrName.indexOf('-' + 1))) + action.payload);
        let indexThresh = returnIndexValName(action.payload.valueName, state.valueName);
        if (indexThresh !== -1){
          state.minThreshold[indexThresh] += action.payload.value;
        }
      },
      changeMaxEdgeMenu: (state, action: PayloadAction<MenuSlice>) => {
        let indexThresh = returnIndexValName(action.payload.valueName, state.valueName);
        if (indexThresh !== -1){
          state.maxEdge[indexThresh] = action.payload.value;
        }
      },
      changeMinEdgeMenu: (state, action: PayloadAction<MenuSlice>) => {
        let indexThresh = returnIndexValName(action.payload.valueName, state.valueName);
        if (indexThresh !== -1){
          state.minEdge[indexThresh] = action.payload.value;
        }
      },
      changeMaxThresholdMenu: (state, action: PayloadAction<MenuSlice>) => {
        let indexThresh = returnIndexValName(action.payload.valueName, state.valueName);
        if (indexThresh !== -1){
          state.maxThreshold[indexThresh] = action.payload.value;
        }
      },
      changeMinThresholdMenu: (state, action: PayloadAction<MenuSlice>) => {
        let indexThresh = returnIndexValName(action.payload.valueName, state.valueName);
        if (indexThresh !== -1){
          state.minThreshold[indexThresh] = action.payload.value;
        }
      },
      modifyBasedInterface:(state, action: PayloadAction<MenuSlice>) => {

      }
      // TODO maybe?
      // setValueName: (state, action: PayloadAction<string>) => { state.valueName = (action.payload==="a")?'voluptate':(action.payload==="b")?'aliquip':(action.payload==="c")?'consectetur':'laboris';  }
    },
    // // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
    // extraReducers: (builder) => { builder .addCase(incrementAsync.pending, (state) => { state.status = 'loading'; }) .addCase(incrementAsync.fulfilled, (state, action) => { state.status = 'idle'; state.value += action.payload; }) .addCase(incrementAsync.rejected, (state) => { state.status = 'failed'; }); },
  });
    
  export const { 
    incrementByAmountMenu, 
    changeMaxEdgeMenu, changeMinEdgeMenu, changeMaxThresholdMenu, changeMinThresholdMenu 
  } = filterMenuSlice.actions;
  
  // The function below is called a selector and allows us to select a value from
  // the state. Selectors can also be defined inline where they're used instead of
  // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

  export const selectFilterMenu = (state: RootState) => state.filterMenu;
  
  export default filterMenuSlice.reducer;
  