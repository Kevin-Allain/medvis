import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';

import { Patient } from '../../interface/Patient';

import dataGenerated from '../../../data/generated.json'

const patients = dataGenerated as Patient[];


export interface FilterMenuState {
    minEdge: Array<number>;
    maxEdge: Array<number>;
    minThreshold: Array<number>;
    maxThreshold: Array<number>;
    // status: 'idle' | 'loading' | 'failed';
    valueName: Array<'voluptate' | 'aliquip' | 'consectetur' | 'laboris'>; // doubt whether we want this...
    patients:Array<Patient>,
  }

  const initialState: FilterMenuState = {
    minEdge: [0,0,0,0],
    maxEdge: [1000,1000,1000,1000],
    minThreshold: [0,0,0,0],
    maxThreshold: [1000,1000,1000,1000],
    // status: 'idle',
    valueName: ['voluptate','aliquip','consectetur','laboris'],
    patients : patients,
  };


  
  export const filterMenuSlice = createSlice({
    name: 'filterMenu',
    initialState,
    reducers: {
      // // Use the PayloadAction type to declare the contents of `action.payload`
      // TODO alternative approach to array (Interface Props)
      incrementByAmount: (state, action: PayloadAction<[number,string]>) => {
        // state.attrName = state.attrName.substr(0, state.attrName.indexOf('-') + 1) + (parseInt(state.attrName.substr(state.attrName.indexOf('-' + 1))) + action.payload);
        let indexThresh = -1;
        switch (action.payload[1]){
          case 'voluptate':
            indexThresh = state.valueName.indexOf('voluptate');
            break;
          case 'aliquip':
            indexThresh = state.valueName.indexOf('aliquip');
            break;
          case 'consectetur':
            indexThresh = state.valueName.indexOf('consectetur');
            break;
          case 'laboris':
            indexThresh = state.valueName.indexOf('laboris');
            break;
        }
        if (indexThresh !== -1){
          state.minThreshold[indexThresh] += action.payload[0];
        }
      },
      // // randomize: (state, action: PayloadAction<void>) => { state.attrName = state.attrName.substr(0, state.attrName.indexOf('-') + 1) + Math.round(1000 * Math.random()); },
      // changeMaxEdge: (state, action: PayloadAction<number>) => {
      //   state.maxEdge = Math.max(state.minEdge,action.payload);
      // },
      // changeMinEdge: (state, action: PayloadAction<number>) => {
      //   state.minEdge = Math.min(state.maxEdge,action.payload);
      // },
      // changeMaxThreshold: (state, action: PayloadAction<number>) => {
      //   state.maxThreshold = action.payload;
      // },
      // changeMinThreshold: (state, action: PayloadAction<number>) => {
      //   state.minThreshold = action.payload;
      // },
      // setValueName: (state, action: PayloadAction<string>) => {
      //   state.valueName = (action.payload==="a")?'voluptate':(action.payload==="b")?'aliquip':(action.payload==="c")?'consectetur':'laboris';
      // }
    },
    // // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
    // extraReducers: (builder) => { builder .addCase(incrementAsync.pending, (state) => { state.status = 'loading'; }) .addCase(incrementAsync.fulfilled, (state, action) => { state.status = 'idle'; state.value += action.payload; }) .addCase(incrementAsync.rejected, (state) => { state.status = 'failed'; }); },
  });
    
  export const { 
    incrementByAmount, 
    // changeMaxEdge, changeMinEdge, changeMaxThreshold, changeMinThreshold 
  } = filterMenuSlice.actions;
  
  // The function below is called a selector and allows us to select a value from
  // the state. Selectors can also be defined inline where they're used instead of
  // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

  export const selectFilterMenu = (state: RootState) => state.filterMenu;
  
  export default filterMenuSlice.reducer;
  