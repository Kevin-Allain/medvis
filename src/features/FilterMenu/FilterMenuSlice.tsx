import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';

import { Patient } from '../../interface/Patient';

import dataGenerated from '../../../data/generated.json'

const patients = dataGenerated as Patient[];


export interface FilterMenuState {
    minEdge: Array<number>;
    maxEdge: Array<number>;
    minThreshold: Array<number>;
    maxThreshold: Array<number>;
    // status: 'idle' | 'loading' | 'failed';
    valueName: Array<'voluptate' | 'aliquip' | 'consectetur' | 'laboris'>; // doubt whether we want this...
    patients:Array<Patient>,
  }

  const initialState: FilterMenuState = {
    minEdge: [0,0,0,0],
    maxEdge: [1000,1000,1000,1000],
    minThreshold: [0,0,0,0],
    maxThreshold: [1000,1000,1000,1000],
    // status: 'idle',
    valueName: ['voluptate','aliquip','consectetur','laboris'],
    patients : patients,
  };

  // verify according to stringVer what is the valueName of medical test and identify index in arrays of values
  const returnIndexValName = (stringVer:string, arrVer:Array<string>) => {
    let indexThresh = -1;
    switch (stringVer){
      case 'voluptate':
        indexThresh = arrVer.indexOf('voluptate');
        break;
      case 'aliquip':
        indexThresh = arrVer.indexOf('aliquip');
        break;
      case 'consectetur':
        indexThresh = arrVer.indexOf('consectetur');
        break;
      case 'laboris':
        indexThresh = arrVer.indexOf('laboris');
        break;
    }
    return indexThresh;
  }
  
  export const filterMenuSlice = createSlice({
    name: 'filterMenu',
    initialState,
    reducers: {
      // // Use the PayloadAction type to declare the contents of `action.payload`
      // TODO alternative approach to array (Interface Props)
      incrementByAmountMenu: (state, action: PayloadAction<[number,string]>) => {
        // state.attrName = state.attrName.substr(0, state.attrName.indexOf('-') + 1) + (parseInt(state.attrName.substr(state.attrName.indexOf('-' + 1))) + action.payload);
        let indexThresh = returnIndexValName(action.payload[1], state.valueName);
        if (indexThresh !== -1){
          state.minThreshold[indexThresh] += action.payload[0];
        }
      },
      // // randomize: (state, action: PayloadAction<void>) => { state.attrName = state.attrName.substr(0, state.attrName.indexOf('-') + 1) + Math.round(1000 * Math.random()); },
      changeMaxEdgeMenu: (state, action: PayloadAction<[number,string]>) => {
        let indexThresh = returnIndexValName(action.payload[1], state.valueName);
        if (indexThresh !== -1){
          state.maxEdge[indexThresh] = action.payload[0];
        }
      },
      changeMinEdgeMenu: (state, action: PayloadAction<[number,string]>) => {
        let indexThresh = returnIndexValName(action.payload[1], state.valueName);
        if (indexThresh !== -1){
          state.minEdge[indexThresh] = action.payload[0];
        }
      },
      changeMaxThresholdMenu: (state, action: PayloadAction<[number,string]>) => {
        let indexThresh = returnIndexValName(action.payload[1], state.valueName);
        if (indexThresh !== -1){
          state.maxThreshold[indexThresh] = action.payload[0];
        }
      },
      changeMinThresholdMenu: (state, action: PayloadAction<[number,string]>) => {
        let indexThresh = returnIndexValName(action.payload[1], state.valueName);
        if (indexThresh !== -1){
          state.minThreshold[indexThresh] = action.payload[0];
        }
      },
      // TODO maybe?
      // setValueName: (state, action: PayloadAction<string>) => {
      //   state.valueName = (action.payload==="a")?'voluptate':(action.payload==="b")?'aliquip':(action.payload==="c")?'consectetur':'laboris';
      // }
    },
    // // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
    // extraReducers: (builder) => { builder .addCase(incrementAsync.pending, (state) => { state.status = 'loading'; }) .addCase(incrementAsync.fulfilled, (state, action) => { state.status = 'idle'; state.value += action.payload; }) .addCase(incrementAsync.rejected, (state) => { state.status = 'failed'; }); },
  });
    
  export const { 
    incrementByAmountMenu, 
    changeMaxEdgeMenu, changeMinEdgeMenu, changeMaxThresholdMenu, changeMinThresholdMenu 
  } = filterMenuSlice.actions;
  
  // The function below is called a selector and allows us to select a value from
  // the state. Selectors can also be defined inline where they're used instead of
  // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`

  export const selectFilterMenu = (state: RootState) => state.filterMenu;
  
  export default filterMenuSlice.reducer;
  